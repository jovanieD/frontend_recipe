(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-paginate', ['exports', '@angular/core', '@angular/common'], factory) :
    (global = global || self, factory(global['ngx-paginate'] = {}, global.ng.core, global.ng.common));
}(this, function (exports, core, common) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    var PageState = /** @class */ (function () {
        function PageState() {
        }
        return PageState;
    }());
    var PaginateOptions = /** @class */ (function () {
        function PaginateOptions() {
        }
        return PaginateOptions;
    }());
    var defaults = {
        spanPages: 2,
        previousPage: true,
        nextPage: true,
        firstPage: true,
        lastPage: true,
        titles: {
            firstPage: 'First',
            previousPage: 'Previous',
            lastPage: 'Last',
            nextPage: 'Next',
            pageSize: 'Items per page'
        },
        pageSizes: [{
                value: 5,
                display: '5'
            }, {
                value: 10,
                display: '10'
            }, {
                value: 15,
                display: '15'
            }]
    };
    var NgxPaginateComponent = /** @class */ (function () {
        function NgxPaginateComponent() {
            this.pageChange = new core.EventEmitter();
            this.pageSizeChange = new core.EventEmitter();
            this.range = [];
        }
        NgxPaginateComponent.prototype.ngOnInit = function () {
            this.range = [];
            this.setOptions();
            this.calculateRange();
            // this.pageChange.emit(this.page);
        };
        NgxPaginateComponent.prototype.setOptions = function () {
            if (!this.options) {
                this.options = defaults;
            }
            if (!this.options.titles) {
                this.options.titles = defaults.titles;
            }
            this.internalOptions = {
                spanPages: this.options.spanPages || defaults.spanPages,
                previousPage: this.options.previousPage !== undefined ? this.options.previousPage : defaults.previousPage,
                nextPage: this.options.nextPage !== undefined ? this.options.nextPage : defaults.nextPage,
                firstPage: this.options.firstPage !== undefined ? this.options.firstPage : defaults.firstPage,
                lastPage: this.options.lastPage !== undefined ? this.options.lastPage : defaults.lastPage,
                titles: {
                    firstPage: this.options.titles.firstPage || defaults.titles.firstPage,
                    previousPage: this.options.titles.previousPage || defaults.titles.previousPage,
                    lastPage: this.options.titles.lastPage || defaults.titles.lastPage,
                    nextPage: this.options.titles.nextPage || defaults.titles.nextPage,
                    pageSize: this.options.titles.pageSize || defaults.titles.pageSize
                },
                pageSizes: this.options.pageSizes || defaults.pageSizes.slice()
            };
        };
        NgxPaginateComponent.prototype.setPageSize = function (pageSize) {
            this.page.pageSize = parseInt(pageSize, 10);
            // this.pageChange.emit(this.page);
            this.pageSizeChange.emit(this.page);
        };
        NgxPaginateComponent.prototype.calculateRange = function () {
            this.range.length = 0;
            this.page.numberOfPages = Math.ceil(this.page.totalItems / this.page.pageSize);
            if (this.page.numberOfPages === 0) {
                this.page.numberOfPages = 1;
            }
            var upperSpan;
            // if we can add span in front of current page, add it
            if (this.page.currentPage - this.options.spanPages > 0) {
                for (var i = this.page.currentPage - this.options.spanPages; i < this.page.currentPage; i++) {
                    this.range.push(i);
                }
                upperSpan = this.options.spanPages;
            }
            else {
                // if not, add as much as you can after it and adjust upper span
                upperSpan = this.options.spanPages * 2;
                for (var i = 1; i < this.page.currentPage; i++) {
                    this.range.push(i);
                    upperSpan--;
                }
            }
            this.range.push(this.page.currentPage);
            if (this.page.currentPage + upperSpan <= this.page.numberOfPages) {
                for (var i = this.page.currentPage + 1; i <= this.page.currentPage + upperSpan; i++) {
                    this.range.push(i);
                }
            }
            else {
                for (var i = this.page.currentPage + 1; i <= this.page.numberOfPages; i++) {
                    this.range.push(i);
                    upperSpan--;
                }
                if (upperSpan > 0) {
                    // something is still left, prepend it to array (only if bigger than 0)
                    while (upperSpan > 0 && this.range[0] - 1 > 0) {
                        this.range.unshift(this.range[0] - 1);
                        upperSpan--;
                    }
                }
            }
        };
        NgxPaginateComponent.prototype.setPage = function (page) {
            if (this.page.currentPage !== page) {
                this.page.currentPage = page;
                this.calculateRange();
                this.pageChange.emit(this.page);
            }
        };
        NgxPaginateComponent.prototype.previousPage = function () {
            if (this.page.currentPage > 1) {
                this.setPage(this.page.currentPage - 1);
            }
        };
        NgxPaginateComponent.prototype.nextPage = function () {
            if (this.page.currentPage < this.page.numberOfPages) {
                this.setPage(this.page.currentPage + 1);
            }
        };
        NgxPaginateComponent.prototype.ngDoCheck = function () {
            if (this.page) {
                this.calculateRange();
            }
        };
        NgxPaginateComponent.prototype.ngOnChanges = function (changes) {
            if (changes['options'] && changes['options'].currentValue) {
                this.setOptions();
            }
        };
        __decorate([
            core.Input(),
            __metadata("design:type", PaginateOptions)
        ], NgxPaginateComponent.prototype, "options", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", PageState)
        ], NgxPaginateComponent.prototype, "page", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], NgxPaginateComponent.prototype, "pageChange", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], NgxPaginateComponent.prototype, "pageSizeChange", void 0);
        NgxPaginateComponent = __decorate([
            core.Component({
                selector: 'ngx-paginate',
                template: "<div class=\"page-size-selection\">\n  <span>{{internalOptions.titles.pageSize}}</span>\n  <select (change)=\"setPageSize($event.target.value)\">\n    <option *ngFor=\"let opt of internalOptions.pageSizes\">{{opt.display}}</option>\n  </select>\n</div>\n<div class=\"pages\">\n  <span\n    class=\"first-page-button page-entry\"\n    *ngIf=\"internalOptions.firstPage\"\n    (click)=\"setPage(1)\"\n    [ngClass]=\"{'disabled':page.currentPage === 1}\">\n    {{internalOptions.titles.firstPage}}\n  </span>\n  <span\n    class=\"prev-button page-entry\"\n    *ngIf=\"internalOptions.previousPage\"\n    (click)=\"previousPage()\"\n    [ngClass]=\"{'disabled':page.currentPage === 1}\">\n    {{internalOptions.titles.previousPage}}\n  </span>\n  <span class=\"page-selection\">\n    <span\n      *ngFor=\"let num of range\"\n      class=\"page-entry\"\n      [ngClass]=\"{'active': num === page.currentPage}\"\n      (click)=\"setPage(num)\">{{num}}</span>\n  </span>\n  <span\n    class=\"next-button page-entry\"\n    *ngIf=\"internalOptions.nextPage\"\n    (click)=\"nextPage()\"\n    [ngClass]=\"{'disabled':page.currentPage === page.numberOfPages}\">\n      {{internalOptions.titles.nextPage}}\n  </span>\n  <span\n    class=\"last-page-button page-entry\"\n    *ngIf=\"internalOptions.lastPage\"\n    (click)=\"setPage(page.numberOfPages)\"\n    [ngClass]=\"{'disabled':page.currentPage === page.numberOfPages}\">\n    {{internalOptions.titles.lastPage}}\n  </span>\n</div>\n",
                styles: [":host{display:flex;width:100%;align-items:center;justify-content:space-between}.page-selection{display:flex;justify-content:center}select{height:30px}.pages{display:flex}.page-entry{height:30px;display:flex;align-items:center;justify-content:center;border:none;background-color:#eeedee;margin:0 1px;cursor:pointer;white-space:nowrap;min-width:14px;width:auto;padding:0 8px}.page-entry.active{color:#fff;background-color:#b6b6b6;cursor:default}.page-entry.disabled{opacity:.3;cursor:default}"]
            }),
            __metadata("design:paramtypes", [])
        ], NgxPaginateComponent);
        return NgxPaginateComponent;
    }());

    var NgxPaginateModule = /** @class */ (function () {
        function NgxPaginateModule() {
        }
        NgxPaginateModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule
                ],
                exports: [NgxPaginateComponent],
                declarations: [NgxPaginateComponent]
            })
        ], NgxPaginateModule);
        return NgxPaginateModule;
    }());

    exports.NgxPaginateComponent = NgxPaginateComponent;
    exports.NgxPaginateModule = NgxPaginateModule;
    exports.PageState = PageState;
    exports.PaginateOptions = PaginateOptions;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ngx-paginate.umd.js.map
